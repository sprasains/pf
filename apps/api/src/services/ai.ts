import { OpenAI } from 'openai';
import { z } from 'zod';
import { PrismaClient } from '@prisma/client';
import { logger } from '../utils/logger';
import { AppError } from '../utils/error';
import { Queue } from 'bullmq';
import { redis } from '../lib/redis';
import { MetricsService } from './metrics';
import { StorageService } from './storage';

const prisma = new PrismaClient();

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Initialize BullMQ queue
export const aiGenerationQueue = new Queue('ai-generation', {
  connection: redis
});

// Validation schemas
const workflowNodeSchema = z.object({
  id: z.string(),
  type: z.string(),
  position: z.object({
    x: z.number(),
    y: z.number()
  }),
  parameters: z.record(z.any())
});

const workflowConnectionSchema = z.object({
  source: z.string(),
  target: z.string(),
  sourceHandle: z.string().optional(),
  targetHandle: z.string().optional()
});

const workflowDefinitionSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  nodes: z.array(workflowNodeSchema),
  connections: z.array(workflowConnectionSchema)
});

// System prompt for the AI
const SYSTEM_PROMPT = `You are an expert workflow automation specialist. Your task is to convert natural language descriptions into n8n-style workflow definitions.

The workflow definition should be a valid JSON object with the following structure:
{
  "name": "string",
  "description": "string (optional)",
  "nodes": [
    {
      "id": "string",
      "type": "string",
      "position": { "x": number, "y": number },
      "parameters": { ... }
    }
  ],
  "connections": [
    {
      "source": "string",
      "target": "string",
      "sourceHandle": "string (optional)",
      "targetHandle": "string (optional)"
    }
  ]
}

Available node types:
- httpRequest: Make HTTP requests
- googleSheets: Interact with Google Sheets
- slack: Send messages to Slack
- airtable: Read/write Airtable records
- function: Custom JavaScript code
- if: Conditional branching
- switch: Multiple conditional branches
- merge: Combine multiple branches
- split: Split workflow into parallel branches

Ensure the workflow is logical, efficient, and follows best practices.`;

export class AIService {
  static async generateWorkflow(prompt: string, userId: string, orgId: string) {
    try {
      logger.info('Starting AI workflow generation', {
        userId,
        orgId,
        promptLength: prompt.length
      });

      const completion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          { role: 'system', content: SYSTEM_PROMPT },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 2000
      });

      const response = completion.choices[0].message.content;
      if (!response) {
        throw new Error('No response from AI model');
      }

      // Parse and validate the response
      const workflowJson = JSON.parse(response);
      const validatedWorkflow = workflowDefinitionSchema.parse(workflowJson);

      // Log the prompt and response
      const aiPrompt = await prisma.aIWorkflowPrompt.create({
        data: {
          userId,
          orgId,
          promptText: prompt,
          responseJson: validatedWorkflow,
          model: 'gpt-4',
          tokenUsage: completion.usage?.total_tokens
        }
      });

      // Update metrics
      await MetricsService.incrementCounter('total_ai_prompts');
      if (completion.usage?.total_tokens) {
        await MetricsService.incrementCounter('total_tokens', completion.usage.total_tokens);
      }

      // Backup to S3
      await StorageService.backupAIResponse(aiPrompt.id, {
        prompt,
        response: validatedWorkflow,
        metadata: {
          userId,
          orgId,
          model: 'gpt-4',
          tokenUsage: completion.usage
        }
      });

      logger.info('AI workflow generation completed', {
        promptId: aiPrompt.id,
        userId,
        orgId,
        tokenUsage: completion.usage?.total_tokens,
        workflowName: validatedWorkflow.name
      });

      return {
        workflow: validatedWorkflow,
        promptId: aiPrompt.id
      };
    } catch (error) {
      logger.error('AI workflow generation failed', {
        error,
        userId,
        orgId,
        prompt
      });

      // Update failed metrics
      await MetricsService.incrementCounter('failed_ai_calls');

      if (error instanceof z.ZodError) {
        throw new AppError('Invalid workflow structure generated by AI', 400);
      }

      throw new AppError('Failed to generate workflow', 500);
    }
  }

  static async generateAndSaveWorkflow(
    prompt: string,
    userId: string,
    orgId: string
  ) {
    try {
      const { workflow, promptId } = await this.generateWorkflow(prompt, userId, orgId);

      // Create the workflow definition
      const workflowDefinition = await prisma.workflowDefinition.create({
        data: {
          name: workflow.name,
          description: workflow.description,
          definition: workflow,
          sourceType: 'AI',
          aiPromptId: promptId,
          userId,
          orgId
        }
      });

      logger.info('Workflow saved successfully', {
        workflowId: workflowDefinition.id,
        promptId,
        userId,
        orgId
      });

      return workflowDefinition;
    } catch (error) {
      logger.error('Failed to generate and save workflow', {
        error,
        userId,
        orgId,
        prompt
      });
      throw error;
    }
  }

  static async listPrompts(userId: string, orgId: string, page = 1, limit = 10) {
    try {
      const prompts = await prisma.aIWorkflowPrompt.findMany({
        where: {
          userId,
          orgId
        },
        orderBy: {
          createdAt: 'desc'
        },
        skip: (page - 1) * limit,
        take: limit,
        include: {
          workflows: {
            select: {
              id: true,
              name: true,
              description: true
            }
          }
        }
      });

      const total = await prisma.aIWorkflowPrompt.count({
        where: {
          userId,
          orgId
        }
      });

      logger.info('Listed AI prompts', {
        userId,
        orgId,
        page,
        limit,
        total
      });

      return {
        prompts,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      logger.error('Failed to list AI prompts', { error, userId, orgId });
      throw new AppError('Failed to list prompts', 500);
    }
  }

  static async getPrompt(id: string, userId: string, orgId: string) {
    try {
      const prompt = await prisma.aIWorkflowPrompt.findFirst({
        where: {
          id,
          userId,
          orgId
        },
        include: {
          workflows: {
            select: {
              id: true,
              name: true,
              description: true,
              createdAt: true
            }
          }
        }
      });

      if (!prompt) {
        throw new AppError('Prompt not found', 404);
      }

      logger.info('Retrieved AI prompt', {
        promptId: id,
        userId,
        orgId
      });

      return prompt;
    } catch (error) {
      if (error instanceof AppError) throw error;
      logger.error('Failed to get AI prompt', { error, id, userId, orgId });
      throw new AppError('Failed to get prompt', 500);
    }
  }
} 